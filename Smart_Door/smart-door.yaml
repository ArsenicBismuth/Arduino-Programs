substitutions:
  telegram_token: !secret telegram_bot_token
  telegram_chat: !secret telegram_chat_id

esphome:
  name: smart-door
  on_boot:
    - priority: 550
      then: # Power connected = closed
        - button.press: door_close

esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf

# Enable logging
logger:
  logs:
    # Prevent component from spamming the logs
    http_request.idf: ERROR

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: "Ab-Apart"
  password: !secret wifi_password
  fast_connect: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Smart-Door Fallback Hotspot"
    password: !secret ap_password

captive_portal:

http_request:

time:
  - platform: sntp
    id: time_now
    timezone: Europe/Berlin

globals:
  - id: global_open_time
    type: std::string
    restore_value: true
    initial_value: ""
  - id: global_close_time
    type: std::string
    restore_value: true
    initial_value: ""
  - id: last_update_id
    type: int
    restore_value: true
    initial_value: "0"

# UI Controls
number:
  - platform: template
    id: servo_duration
    name: Servo Rotation Duration
    min_value: 1
    initial_value: 4.5
    max_value: 6
    step: 0.5
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_servo_settings
  - platform: template
    id: servo_number
    name: Servo Control
    min_value: -100
    initial_value: 0
    max_value: 100
    step: 1
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_servo_settings
    set_action:
      # Detach if given value is 0
      then:
        - servo.write:
            id: servo_hw
            level: !lambda 'return x / 100.0;'
        - if:
            condition:
              lambda: 'return x == 0;'
            then:
              - delay: !lambda 'return 50;'
              - servo.detach:
                  id: servo_hw
              - logger.log:
                  format: "Servo detached"

button:
  # Most components have REST API, read more: https://esphome.io/web-api/#api-rest
  - platform: template
    name: Open
    id: door_open
    # Equivalent: http://smart-door.local/button/open/press (using name, not id)
    web_server:
      sorting_group_id: sorting_group_door_actions
    on_press:
      # Move servo until the door is opened, or timeout
      - globals.set:
          id: global_open_time
          value: !lambda |-
            char str[30];
            time_t currTime = id(time_now).now().timestamp;
            strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
            return std::string(str);
      - number.set:
          id: servo_number
          value: -100
      - wait_until:
          condition:
            binary_sensor.is_on: door_sensor
          timeout: !lambda 'return id(servo_duration).state * 1000 + 1000;'
      # Continue opening a bit after the door is opened
      - delay: !lambda 'return 3000;'
      - number.set:
          id: servo_number
          value: 0
  - platform: template
    name: Close
    id: door_close
    web_server:
      sorting_group_id: sorting_group_door_actions
    on_press:
      # Only trigger closing if the door is not currently opening
      - globals.set:
          id: global_close_time
          value: !lambda |-
            char str[30];
            time_t currTime = id(time_now).now().timestamp;
            strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
            return std::string(str);
      - if:
          condition:
            lambda: 'return id(servo_number).state >= 0;'
          then:
            - number.set:
                id: servo_number
                value: 100
            - delay: !lambda 'return id(servo_duration).state * 1000;'
            - number.set:
                id: servo_number
                value: 0
  - platform: template
    name: Zero
    id: servo_zero
    web_server:
      sorting_group_id: sorting_group_servo_settings
    on_press:
      then:
        - number.set:
            id: servo_number
            value: 0
  # Hidden button to trigger status message (called from interval)
  - platform: template
    id: send_status_message
    internal: true
    on_press:
      then:
        - http_request.post:
            url: "https://api.telegram.org/bot${telegram_token}/sendMessage"
            request_headers:
              Content-Type: application/json
            json: |-
              std::string status_emoji = id(door_sensor).state ? "ðŸŸ©" : "ðŸŸ¥";
              std::string status_text = id(door_sensor).state ? "OPEN" : "CLOSED";
              
              std::string message = "*Status: Door is " + status_text + "* " + status_emoji + "\n";
              message += "â€¢ Last opened: " + id(time_open).state + "\n";
              message += "â€¢ Last closed: " + id(time_close).state;
              
              root["chat_id"] = ${telegram_chat};
              root["text"] = message;
              root["parse_mode"] = "Markdown";

interval:
  # Poll Telegram for new messages every 1 second
  - interval: 1s
    then:
      - http_request.get:
          url: "https://api.telegram.org/bot${telegram_token}/getUpdates?offset=-1&limit=1"
          capture_response: true
          on_response:
            - if:
                condition:
                  lambda: return response->status_code == 200;
                then:
                  - lambda: |-
                      json::parse_json(body, [](JsonObject root) -> bool {
                        // Check if response is ok and has results
                        if (!root["ok"] || !root["result"].is<JsonArray>()) {
                          return false;
                        }
                        
                        JsonArray results = root["result"].as<JsonArray>();
                        if (results.size() == 0) {
                          return false;
                        }
                        
                        // Get the latest update
                        JsonObject update = results[0];
                        int update_id = update["update_id"] | 0;
                        
                        // Skip if already processed
                        if (update_id <= id(last_update_id)) {
                          return false;
                        }
                        id(last_update_id) = update_id;
                        
                        // Get message text (check both message and edited_message)
                        JsonVariant msg_var = update["message"];
                        if (msg_var.isNull()) {
                          msg_var = update["edited_message"];
                        }
                        if (msg_var.isNull()) {
                          return false;
                        }
                        
                        const char* text = msg_var["text"] | "";
                        ESP_LOGI("telegram", "Received: %s", text);
                        
                        // Handle /status command
                        if (strcmp(text, "/status") == 0) {
                          id(send_status_message).press();
                        }
                        
                        return true;
                      });
                else:
                  - logger.log:
                      format: "Telegram API error: %d"
                      args: ['response->status_code']

text_sensor:
  # Just for displaying globals in web UI
  - platform: template
    id: time_close
    name: Door Last Closed
    lambda: 'return id(global_close_time);'
    update_interval: 30s
  - platform: template
    id: time_open
    name: Door Last Opened
    lambda: 'return id(global_open_time);'
    update_interval: 30s

# Hardwares
binary_sensor:
  # Optional, only when using a battery (always on)
  - platform: gpio
    id: door_sensor
    name: Door Sensor
    device_class: door
    pin:
      number: GPIO12
      mode:
        input: true
        pullup: true
        # Means door is closed on release
    filters:
      # 2s wait to allow magnetic connector to connect
      - delayed_off: 2000ms
    on_release:
      then: # Low = closed. Auto-lock when door is closed
        - button.press: door_close
  - platform: gpio
    id: door_button
    name: Door Button
    device_class: door
    pin:
      number: GPIO14
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on_off: 100ms
    on_press:
      then: # High = pressed. Open the door
        - button.press: door_open

servo:
  - id: servo_hw
    output: servo_pwm_output

output:
  - platform: ledc
    id: servo_pwm_output
    pin: GPIO13
    frequency: 50Hz

web_server:
  version: 3
  port: 80
  sorting_groups:
    - id: sorting_group_door_actions
      name: "Door Actions"
      sorting_weight: 10
    - id: sorting_group_servo_settings
      name: "Servo Settings"
      sorting_weight: 20