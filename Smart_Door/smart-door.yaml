substitutions:
  telegram_token: !secret telegram_bot_token
  telegram_chat: !secret telegram_chat_id
  use_battery: false
  use_telegram: false
    # No battery: Auto-close on power.
    # Battery: Close on door sensor.

esphome:
  name: smart-door
  on_boot:
    - priority: 550
      then: # No-battery mode: Power connected = closed
        - if:
            condition:
              lambda: return ${0 if use_battery else 1};
            then:
              - button.press: door_close
              - delay: !lambda 'return id(servo_duration).state * 1000 + 1000;'
              - button.press: send_status_message
              # Wait for the door to close and send status
              # If it's completely open = power disconnected = no message.
              # If it's partially open = power connected but sensor says open = "OPENED" message.

esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf
    sdkconfig_options:
        CONFIG_LWIP_MAX_SOCKETS: '16'

safe_mode:
  disabled: true

# Enable logging
logger:
  level: ERROR
  initial_level: ERROR
  logs:
    # Prevent component from spamming the logs
    http_request.idf: ERROR

# Enable Home Assistant API
api:
  password: ""
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: "Ab-Apart"
  password: !secret wifi_password
  fast_connect: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Smart-Door Fallback Hotspot"
    password: !secret ap_password

captive_portal:

http_request:

time:
  - platform: sntp
    id: time_now
    timezone: Europe/Berlin
    on_time_sync:
      - if:
          condition:
            lambda: return id(pending_close_time) == true;
          then:
            # Update the previously pending close time
            - globals.set:
                id: global_close_time
                value: !lambda |-
                  time_t currTime = id(time_now).now().timestamp;
                  return currTime;
            - globals.set:
                id: pending_close_time
                value: "false"

globals:
  - id: global_open_time
    type: time_t
    restore_value: true
    initial_value: ""
  - id: global_close_time
    type: time_t
    restore_value: true
    initial_value: ""
  - id: last_update_id
    type: int
    restore_value: true
    initial_value: "0"
  - id: pending_close_time
    type: bool
    restore_value: false
    initial_value: "false"
  - id: telegram_poll_counter
    type: int
    restore_value: false
    initial_value: "0"

# Enables the ability to read debug information.
debug:
  update_interval: 1min # How often to check the memory.

sensor:
  # Creates a sensor in Home Assistant with the free memory value.
  - platform: debug
    free:
      name: "Heap Free"
      unit_of_measurement: "B" # B for Bytes
      icon: "mdi:memory"

# UI Controls
number:
  - platform: template
    id: servo_duration
    name: Servo Rotation Duration
    icon: "mdi:timer-sand"
    min_value: 1
    restore_value: true
    initial_value: 4.5
    max_value: 6
    step: 0.5
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_servo_settings
  - platform: template
    id: servo_number
    name: Servo Control
    icon: "mdi:rotate-right"
    min_value: -100
    initial_value: 0
    max_value: 100
    step: 1
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_servo_settings
    set_action:
      # Detach if given value is 0
      then:
        - servo.write:
            id: servo_hw
            level: !lambda 'return x / 100.0;'
        - if:
            condition:
              lambda: 'return x == 0;'
            then:
              - delay: !lambda 'return 50;'
              - servo.detach:
                  id: servo_hw
              - logger.log:
                  format: "Servo detached"

button:
  # Most components have REST API, read more: https://esphome.io/web-api/#api-rest
  - platform: template
    name: Open
    id: door_open
    icon: "mdi:lock-open-variant-outline"
    # Equivalent: http://smart-door.local/button/open/press (using name, not id)
    web_server:
      sorting_group_id: sorting_group_door_actions
    on_press:
      # Move servo until the door is opened, or timeout
      if:
        condition: # Only if not currently moving
          lambda: 'return id(servo_number).state == 0;'
        then:
        - button.press: send_opening_message
        - globals.set:
            id: global_open_time
            value: !lambda |-
              time_t currTime = id(time_now).now().timestamp;
              return currTime;
        - number.set:
            id: servo_number
            value: -100
        - delay: !lambda 'return id(servo_duration).state * 1000 + 2000;'
        - number.set:
            id: servo_number
            value: 0
  - platform: template
    name: Close
    id: door_close
    icon: "mdi:lock-outline"
    web_server:
      sorting_group_id: sorting_group_door_actions
    on_press:
      # Only trigger closing if the door is not currently opening
      - if:
          condition:
            time.has_time:
          then:
            - globals.set:
                id: global_close_time
                value: !lambda |-
                  time_t currTime = id(time_now).now().timestamp;
                  return currTime;
          else:
            - globals.set:
                id: pending_close_time
                value: "true"
      - if:
          condition:
            lambda: 'return id(servo_number).state >= 0;'
          then:
            - number.set:
                id: servo_number
                value: 100
            - delay: !lambda 'return id(servo_duration).state * 1000;'
            - number.set:
                id: servo_number
                value: 0
  - platform: template
    name: Zero
    id: servo_zero
    icon: "mdi:numeric-0-circle-outline"
    web_server:
      sorting_group_id: sorting_group_servo_settings
    on_press:
      then:
        - number.set:
            id: servo_number
            value: 0
  # Hidden button to trigger status message (called from interval)
  - platform: template
    id: send_status_message
    internal: true
    on_press:
      then:
        - if:
            condition:
              lambda: return ${1 if use_telegram else 0};
            then:
              - http_request.post:
                  url: "https://api.telegram.org/bot${telegram_token}/sendMessage"
                  request_headers:
                    Content-Type: application/json
                  json: |-
                    std::string status_emoji = id(door_is_open).state ? "ðŸŸ¥" : "ðŸŸ©";
                    std::string status_text = id(door_is_open).state ? "OPEN" : "CLOSED";

                    char str[30];
                    time_t currTime = id(global_open_time);
                    strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
                    std::string open_time = std::string(str);

                    currTime = id(global_close_time);
                    strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
                    std::string close_time = std::string(str);

                    std::string message = "*Status: Door is " + status_text + "* " + status_emoji + "\n";
                    message += "â€¢ Last opened: " + open_time + "\n";
                    message += "â€¢ Last closed: " + close_time;
                    
                    root["chat_id"] = ${telegram_chat};
                    root["text"] = message;
                    root["parse_mode"] = "Markdown";
  - platform: template
    id: send_opening_message
    internal: true
    on_press:
      - if:
          condition:
            lambda: return ${1 if use_telegram else 0};
          then:
            - http_request.post:
                url: "https://api.telegram.org/bot${telegram_token}/sendMessage"
                request_headers:
                  Content-Type: application/json
                json: |-
                  std::string message = "*Status: Door is OPENING...* ðŸŸ¥\n";
                  
                  root["chat_id"] = ${telegram_chat};
                  root["text"] = message;
                  root["parse_mode"] = "Markdown";
  - platform: restart
    name: "Restart"
    icon: "mdi:restart"
    entity_category: diagnostic

interval:
  - interval: 1s
    then:
      # Poll Telegram for new messages every N seconds (or 5N when door is open). This allows faster detection of open => close.
      - lambda: |-
          // Increment counter
          id(telegram_poll_counter) = id(telegram_poll_counter) + 1;
          
          // If door is open, only poll every 5 seconds (every 5th trigger)
          // If door is closed, poll every second
          bool should_poll = (!id(door_is_open).state) || (id(telegram_poll_counter) >= 5);
          if (should_poll) {
            id(telegram_poll_counter) = 0;  // Reset counter
          }
      - if:
          condition:
            lambda: return id(telegram_poll_counter) == 0 && ${1 if use_telegram else 0};
          then:
            - http_request.get:
                url: "https://api.telegram.org/bot${telegram_token}/getUpdates?offset=-1&limit=1"
                capture_response: true
                on_error:
                  - logger.log:
                      format: "Telegram API error: %d"
                      args: ['response->status_code']
                on_response:
                  - if:
                      condition:
                        lambda: return response->status_code == 200;
                      then:
                        - lambda: |-
                            // Simple string search instead of JSON parsing
                            std::string body_str = body;
                            
                            // Check if response contains "ok":true
                            if (body_str.find("\"ok\":true") == std::string::npos) {
                              return;
                            }
                            
                            // Find update_id in the response
                            size_t update_id_pos = body_str.find("\"update_id\":");
                            if (update_id_pos == std::string::npos) {
                              return;
                            }
                            
                            // Extract update_id value
                            size_t id_start = body_str.find_first_of("0123456789", update_id_pos);
                            if (id_start == std::string::npos) {
                              return;
                            }
                            size_t id_end = body_str.find_first_not_of("0123456789", id_start);
                            if (id_end == std::string::npos) {
                              id_end = body_str.length();
                            }
                            
                            int update_id = std::stoi(body_str.substr(id_start, id_end - id_start));
                            
                            // Skip if already processed
                            if (update_id <= id(last_update_id)) {
                              return;
                            }
                            id(last_update_id) = update_id;
                            
                            // Search for message text (check just "message", ignore "edited_message")
                            size_t msg_pos = body_str.find("\"message\":");
                            if (msg_pos == std::string::npos) {
                              return;
                            }
                            
                            // Find text field within the message
                            size_t text_pos = body_str.find("\"text\":\"", msg_pos);
                            if (text_pos == std::string::npos) {
                              return;
                            }
                            
                            // Extract text value
                            size_t text_start = text_pos + 8; // Length of "\"text\":\""
                            size_t text_end = body_str.find("\"", text_start);
                            if (text_end == std::string::npos) {
                              return;
                            }
                            
                            std::string text = body_str.substr(text_start, text_end - text_start);
                            
                            // Handle commands
                            if (text == "/status") {
                              id(send_status_message).press();
                            } else if (text == "/open") {
                              id(door_open).press();
                              // Telegram can also schedule send by long-press the send button
                            }
                      else:
                        - logger.log:
                            format: "Telegram API error: %d"
                            args: ['response->status_code']

text_sensor:
  # Just for displaying globals in web UI
  - platform: template
    id: time_close
    name: Door Last Closed
    icon: "mdi:timer-lock-outline"
    lambda: |-
      char str[30];
      time_t currTime = id(global_close_time);
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
      return std::string(str);
    update_interval: 30s
  - platform: template
    id: time_open
    name: Door Last Opened
    icon: "mdi:timer-lock-open-outline"
    lambda: |-
      char str[30];
      time_t currTime = id(global_open_time);
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
      return std::string(str);
    update_interval: 30s
  # Creates a sensor that shows the reason for the last reboot.
  - platform: debug
    reset_reason:
      name: "Reset Reason"
      icon: "mdi:information-outline"

# Hardwares
binary_sensor:
  # Optional, only when using a battery (always on)
  - platform: gpio
    id: door_is_open
    name: Door is Open
    device_class: door
    icon: "mdi:door-open"
    pin:
      number: GPIO12
      mode:
        input: true
        pullup: true
        # Means door is closed on release
    filters:
      - delayed_off: 100ms
    # on_release: # Not used for battery-less mode
    #   then: # Low = closed. Auto-lock when door is closed
    #     - button.press: door_close
  - platform: gpio
    id: door_button
    name: Door Button
    device_class: door
    icon: "mdi:exit-run"
    pin:
      number: GPIO14
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on_off: 20ms
    on_press:
      then: # High = pressed. Open the door
        - button.press: door_open

servo:
  - id: servo_hw
    output: servo_pwm_output

output:
  - platform: ledc
    id: servo_pwm_output
    pin: GPIO13
    frequency: 50Hz

web_server:
  version: 3
  port: 80
  sorting_groups:
    - id: sorting_group_door_actions
      name: "Door Actions"
      sorting_weight: 10
    - id: sorting_group_servo_settings
      name: "Servo Settings"
      sorting_weight: 20